<html>
  <head>
    <style>
      textarea {
        width: 48%;
        height: 90%;
        display: inline-block;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
    </style>
    <script src="js/pushtx.js"></script>
    <script>
      function displayContract(contract) {
          function addToAbidata() {
              abidata.value = "Balance: " + contract.balance;
              abidata.value += "\n\nContract state variables:"
              for (var sym in contract.vars) {
                  abidata.value += "\n" + sym + " = " + JSON.stringify(contract.vars[sym]);
               }
          }
          contract.sync("", addToAbidata);
      }
      function submitCode() {
          api.getContract("", input.value, privkey.value, 1, 3141592,
              displayContract);
      }
    </script>
  </head>
  <body>
    <div style="width: 100%">
      <textarea id="input">
contract NameCoin {

    struct Item {
      address owner;
      uint value;
    }

    address gAddress;
    uint gValue;
    mapping (uint => Item) registry;
    
    function NameCoin() {
        gAddress = msg.sender;
    }

    function register(uint key) {
      if (registry[key].owner == 0) {
         registry[key].owner = msg.sender;
      }
    }

    function transferOwnership(uint key, address newOwner) {
      if (registry[key].owner == msg.sender) {
          registry[key].owner = newOwner;
      }
    }

    function setValue(uint key, uint newValue) {
      if (registry[key].owner == msg.sender) {
        registry[key].value = newValue;
      }
    }

    function getValue(uint key) constant returns (uint value) {
      gValue = registry[key].value;
    }

    function getOwner(uint key) constant returns (address owner) {
      gAddress = registry[key].owner;
    }
}
      </textarea>
      <textarea id="abidata"></textarea>
    </div>
    <table>
      <tr>
        <label for="privkey">Private Key:</label>
        <input id="privkey" style="width: 500px;"
               value="1dd885a423f4e212740f116afa66d40aafdbb3a381079150371801871d9ea281"/>
      </tr>
      <tr>
        <button id="submitButton" onclick="submitCode()"
                >Press here to submit transaction</button>
      </tr>
    </table>
    <h2>API documentation</h2>
    <p>Many of the functions below take an "apiURL", which indicates
    from what server the API queries are to be obtained.  If running a
    server locally, "" is allowed; the canonical one is
    "http://stablenet.blockapps.net".
    <ul>
      <li>Contract object: api.Contract(address, functionABI,
        symbolTable). Methods:
        <ul>
          <li>showStorage(apiURL, callback).  Looks up all global
            ("state") variables named in the Solidity source, parsing
            their stored values into Javascript objects and returning an
            association list { var1Name: var1Val, ... } to the callback
            function.  These objects are:
            <ul>
              <li> bool: boolean
              <li> address: hex string
              <li> int, uint: BigInt (from the big-integer library)
              <li> bytes32: ASCII string
              <li> others: not yet handled...
            </ul>
          <li>address: the address of the contract object, assigned at
            creation.
          <li>makeCall(functionName, args).  Forms the data string to
            be sent in an Ethereum transaction to call the function with
            the given arguments.
          <li>getBalance(apiURL, callback).  Gets the current ether
            balance of the contract.
        </ul>
      <li>api.compile(apiURL, code, callback).  Submits the code to
        the online Solidity compiler, returning the output to the
        callback function.  This output is an object of the form
        {contracts: [{name: contractName, bin: compiledCode}], abis:
        [{abi: contractFunctions}], xabis: {contractName:
        storageLayout}}.  The contractFunctions object is defined by
        Solidity; the storageLayout format varies depending on the
        variable type but always contains fields "bytesUsed" and
        "solidityType".  Some of its entries are type declarations;
        the actual variables have the field "atStorageKey" as well.
      <li>api.submit(apiURL, compiledCode, privateKey, gasPrice,
        gasLimit, callback).  Submits compiled Solidity code via the
        given URL, using the parameters provided.  The response is in
        the form of a comma-separated string of new addresses for the
        contracts it creates, which is returned to the callback.
      <li>api.getStorage(apiURL, address, callback).  Retrieves the
        full storage contents of the contract at the address, provided
        to the callback as an association list {key: value}.  Both the
        key and value are normalized to 64-nibble hex strings.
      <li>api.getContractsCreated(apiURL, txHash, callback).
        Retrieves the list of contracts created (as in api.submit) by
        the transaction whose hash is txHash, and returns it to the
        callback.
      <li>api.getNonce(apiURL, address, callback).  Retrieves the
        current nonce (number of valid transactions sent from) of the
        contract at the given address, and passes it to the callback.
      <li>api.pushTX(nonce, gasPrice, gasLimit, toAddress, ethValue,
        data, privateKey, URL, callback).  Sends a transaction to the
        URL (canonically "/includetransaction") with the given
        parameters, handing the response to callback.  This response is
        simply the query URL to look up the raw transaction
        ("http://stablenet.blockapps.net/query/transaction?hash=txHash"),
        which is probably not what you want.  Thus, callback should
        probably extract txHash and GET from "/transactionResult/txHash"
        to obtain more detailed information.
  </body>
</html>
